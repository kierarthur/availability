<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <meta name="theme-color" content="#111" />
  <link rel="manifest" href="manifest.json" />
  <title>Availability</title>
  <style>
    :root {
      --bg: #0f1115;
      --panel: #161a22;
      --muted: #a7b0c0;
      --text: #e7ecf3;
      --accent: #4f8cff;
      --danger: #e06666;
      --ok: #6aa84f;
      --warn: #c8a94a;
      --tile: #1b212c;
      --tile-hover: #222a38;
      --booked: #4a86e8;
      --blocked: #6aa84f;

      /* Managed from JS */
      --vh: 1vh;                 /* updated via JS; iOS uses visualViewport */
      --header-h: 56px;          /* updated by app.js sizeGrid() */
      --footer-h: 76px;          /* JS overwrites with measured height */
      --rows: 2;                 /* app.js sets (14 tiles / columns) */

      /* Layout helpers */
      --row-gap: .6rem;          /* must match .grid gap */
      --main-vpad: 16px;         /* vertical padding inside <main> */

      /* iPhone-only helpers (safe to keep at 0 elsewhere) */
      --footer-safe: env(safe-area-inset-bottom);
      --ios-bottom-guard: 0px;   /* JS sets ~16–20px on iPhone */
      --ios-tile-budget: 0px;    /* JS sets ~12–16px on iPhone when tight */

      /* Small slack for sub-pixel jitter */
      --row-safety: 12px;
    }

    * { box-sizing: border-box; }

    html, body {
      margin: 0;
      padding: 0;
      background: var(--bg);
      color: var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;

      /* Stop iOS auto-text zoom from changing measurements */
      -webkit-text-size-adjust: 100%;

      /* No page-level scrolling; grid is exact-fit */
      height: calc(var(--vh) * 100);
      overflow: hidden;

      display: flex;
      flex-direction: column;
    }

    header {
      position: sticky; top: 0; z-index: 10;
      display: flex; align-items: center; gap: .6rem; flex-wrap: wrap;
      padding: .6rem .9rem;
      background: rgba(15,17,21,.9); backdrop-filter: blur(6px);
      border-bottom: 1px solid #222936;
      overflow: visible; /* allow the overlay logo to extend */
    }

    /* Candidate name + overlay */
    .name-and-logo {
      position: relative;
      display: flex; flex-direction: column; align-items: flex-start; gap: 0.2rem;
      z-index: 2;
    }

    #candidateName {
      margin: 0;
      font-size: 1.35rem;
      line-height: 1.1;
      font-weight: 800;
      letter-spacing: .2px;
      position: relative;
      z-index: 2;
    }

    .company-logo-overlay {
      position: absolute;
      left: 0;
      top: calc(100% + 4px);
      z-index: 1;
      pointer-events: none;
      opacity: 0.25;
      width: auto; height: auto;
      max-width: min(65vw, 520px);
      max-height: 280px;
    }
    @media (max-width: 900px) {
      .company-logo-overlay { max-width: min(70vw, 420px); max-height: 220px; opacity: 0.22; }
    }
    @media (max-width: 560px) {
      .company-logo-overlay { max-width: 60vw; max-height: 180px; opacity: 0.20; }
    }

    header .spacer { flex: 1; }

    button, .btn {
      appearance: none; border: 0; outline: 0; cursor: pointer;
      border-radius: 10px; padding: .5rem .7rem; font-weight: 600; font-size: .9rem;
      background: var(--panel); color: var(--text);
      transition: background .15s ease, opacity .15s ease;
      position: relative; z-index: 2;
    }
    button:hover { background: #1e2532; }
    button:disabled { opacity: .55; cursor: not-allowed; }
    .btn-primary { background: var(--accent); color: #fff; }
    .btn-ghost { background: transparent; color: var(--muted); }

    main {
      flex: 1; min-height: 0; display: flex; flex-direction: column;
      padding: .6rem .9rem 0;
      max-width: 1024px; width: 100%; margin: 0 auto; box-sizing: border-box;
    }

    #helpMsg {
      display: block;
      margin: .15rem 0 .6rem;
      padding: .45rem .6rem;
      border-radius: 10px; font-size: .9rem;
      color: var(--muted);
      border: 1px solid #2a3446;
      background: #131926;
      flex: 0 0 auto; position: relative; z-index: 1;
    }

    /* Calendar grid fills remaining space exactly */
    .grid {
      flex: 1 1 auto; min-height: 0;
      display: grid; width: 100%; max-width: 100%;
      grid-template-columns: repeat(7, minmax(0, 1fr));
      gap: var(--row-gap);

      /* Available height = viewport - header - footer - paddings/gaps
         - iPhone safe/guard - iOS tile budget + safety; divided by rows */
      grid-auto-rows: calc(
        (
          (var(--vh) * 100)
          - var(--header-h)
          - var(--footer-h)
          - var(--footer-safe)
          - var(--ios-bottom-guard)
          - var(--main-vpad)
          - ((var(--rows) - 1) * var(--row-gap))
          + var(--row-safety)
          - var(--ios-tile-budget)
        ) / var(--rows)
      );
    }
    @media (max-width: 900px) { .grid { grid-template-columns: repeat(5, 1fr); } }
    @media (max-width: 700px) { .grid { grid-template-columns: repeat(4, 1fr); } }
    @media (max-width: 560px) { .grid { grid-template-columns: repeat(3, 1fr); } }

    /* --- Tile layout: status aligned across tiles --- */
    .tile {
      background: var(--tile);
      border: 1px solid #222a36;
      border-radius: 14px;
      padding: .6rem;

      display: grid;
      grid-template-rows: auto auto minmax(1.2em, 1fr); /* header, status, sub */
      transition: background .15s ease;
      overflow: hidden; /* no inner scroll */
    }
    .tile:hover { background: var(--tile-hover); }

    .tile-header {
      display: flex; flex-direction: column; align-items: flex-start; gap: .1rem;
      min-height: 30px; /* stabiliser so tiny wrapping doesn't nudge status */
    }
    .tile-day {
      font-weight: 800; letter-spacing: .5px; font-size: .92rem; color: var(--muted); text-transform: uppercase;
    }
    .tile-date {
      font-size: .92rem; color: var(--text); font-weight: 700; margin-left: 0.05rem;
    }

    .tile-status {
      margin-top: .25rem;
      font-size: .92rem;
      font-weight: 800;
      display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical;
      overflow: hidden;
    }
    .status-pending { color: var(--muted); }
    .status-na      { color: var(--danger); }
    .status-ld,
    .status-n,
    .status-ldn     { color: var(--warn); }
    .status-booked  { color: var(--booked); }
    .status-blocked { color: var(--blocked); }

    .tile-sub {
      margin-top: .2rem;
      color: var(--muted);
      font-size: .8rem;
      line-height: 1.2;
      overflow: hidden;
      min-height: 1.4em; /* keep at least one visible line */
    }
    .tile .edit-note { color: var(--accent); font-size: .78rem; }

    /* Footer: kept in flow so its height is always reserved */
    .footer {
      position: sticky; bottom: 0; z-index: 20;
      background: rgba(15,17,21,.95); backdrop-filter: blur(6px);
      border-top: 1px solid #222936;
      height: var(--footer-h); /* set by JS from measured height */
      padding: .7rem .9rem calc(.7rem + env(safe-area-inset-bottom));
      box-sizing: border-box; width: 100%;
      flex: 0 0 auto;
    }
    .footer-inner {
      max-width: 1024px; margin: 0 auto;
      display: flex; gap: .6rem; align-items: center; width: 100%;
    }
    .footer .spacer { flex: 1; }

    .banner {
      padding: .55rem .7rem; border-radius: 10px; font-size: .88rem;
      border: 1px solid #2a3446; background: #131926; color: #a7b0c0;
    }

    /* Hide visually but keep space so layout doesn't jump */
    .hidden {
      visibility: hidden !important;
      pointer-events: none !important;
      opacity: 0;
    }

    .toast {
      position: fixed; right: .75rem; bottom: calc(5.25rem + env(safe-area-inset-bottom));
      background: #131926; color: var(--text);
      border: 1px solid #2a3446; padding: .6rem .75rem; border-radius: 10px; z-index: 25;
      box-shadow: 0 8px 30px rgba(0,0,0,.35);
      max-width: 90vw; font-size: .9rem;
    }

    /* Short screens: minor base reductions; per-tile fit will fine-tune */
    @media (max-height: 740px) {
      .tile-day, .tile-date { font-size: .9rem; }
      .tile-status { font-size: .9rem; }
    }
  </style>
</head>
<body>
  <header>
    <div class="name-and-logo">
      <h1 id="candidateName"></h1>
      <img src="ARMSLOGO.png" alt="Company Logo" class="company-logo-overlay" />
    </div>
    <div class="spacer"></div>
    <button id="refreshBtn">Refresh</button>
    <button id="installBtn" class="btn-ghost hidden">Install</button>
  </header>

  <main>
    <div id="helpMsg">
      Please tap any date to change your availability — don’t forget to tap <strong>Submit</strong> when you’re done.
    </div>
    <div id="grid" class="grid"></div>
  </main>

  <!-- Footer space is always reserved; only visibility toggles via .hidden -->
  <div id="footer" class="footer hidden" role="region" aria-label="Submission actions">
    <div class="footer-inner">
      <span id="draftMsg" class="banner">You have unsaved changes.</span>
      <div class="spacer"></div>
      <button id="clearBtn" class="btn">Clear changes</button>
      <button id="submitBtn" class="btn-primary">Submit</button>
    </div>
  </div>

  <div id="toast" class="toast hidden" role="status" aria-live="polite"></div>

  <!-- Your app logic -->
  <script src="app.js"></script>

  <!-- iPhone dynamic viewport + measured footer + budgeted shrink -->
  <script>
    (function () {
      const GRID_SEL = '#grid';
      const FOOTER_SEL = '#footer';

      // -------- iPhone detection --------
      const isIOS = (() => {
        if (typeof navigator === 'undefined') return false;
        const ua = navigator.userAgent || '';
        return /iPhone|iPad|iPod/i.test(ua) && !('MSStream' in window);
      })();

      // -------- Dynamic viewport (no scrolling) --------
      function setVH() {
        const h = (isIOS && window.visualViewport)
          ? window.visualViewport.height
          : window.innerHeight;
        document.documentElement.style.setProperty('--vh', (h * 0.01) + 'px');
        if (isIOS) {
          // ensure a persistent visible gap above the home indicator
          document.documentElement.style.setProperty('--ios-bottom-guard', '18px');
        }
      }

      // -------- Measure and reserve real footer height --------
      function setFooterH() {
        const footer = document.querySelector(FOOTER_SEL);
        if (!footer) return;

        const rect = footer.getBoundingClientRect(); // includes safe-area padding
        let measured = Math.max(0, Math.round(rect.height));

        // iPhone: add a guard band to absorb toolbar settle/rounding quirks
        if (isIOS) measured += 16; // tune 12–20px if needed

        document.documentElement.style.setProperty('--footer-h', measured + 'px');

        // On iPhone also shrink tiles slightly to buy breathing room
        if (isIOS) {
          const budget = 14; // tune 12–16px
          document.documentElement.style.setProperty('--ios-tile-budget', budget + 'px');
        } else {
          document.documentElement.style.setProperty('--ios-tile-budget', '0px');
        }
      }

      // Recompute on load, resize, orientation, and visualViewport changes
      setVH();
      window.addEventListener('load', () => { setVH(); setFooterH(); setTimeout(() => { setVH(); setFooterH(); fitAllTiles(); }, 400); });
      window.addEventListener('resize', () => { setVH(); setFooterH(); });
      window.addEventListener('orientationchange', () => setTimeout(() => { setVH(); setFooterH(); fitAllTiles(); }, 250));
      if (window.visualViewport) {
        window.visualViewport.addEventListener('resize', () => { setVH(); setFooterH(); });
      }

      // Observe footer visibility toggles (.hidden class) and recompute layout
      const footer = document.querySelector(FOOTER_SEL);
      if (footer && window.MutationObserver) {
        const mo = new MutationObserver(() => {
          // height is reserved even when hidden, but re-measure anyway
          setFooterH();
          // give iOS time to settle animations then refit tiles
          if (isIOS) setTimeout(fitAllTiles, 250);
        });
        mo.observe(footer, { attributes: true, attributeFilter: ['class', 'style'] });
      }

      // -------- Budgeted shrink engine (Row 3 protected) --------
      const MIN_SUB_PX    = isIOS ? 10 : 11; // details row floor (retina safe on iOS)
      const MIN_STATUS_PX = isIOS ? 11 : 12;
      const MIN_HDR_PX    = isIOS ? 12 : 13; // header floor
      const MIN_LH        = 1.06;            // tight but readable
      const STEP_PX       = 1;               // shrink step
      const EPSILON       = 1.5;             // hysteresis

      const SUB_MIN_LINES = 1.2;             // ~1 line

      function emToPx(el, em) {
        const fs = parseFloat(getComputedStyle(el).fontSize || '13');
        return em * (Number.isFinite(fs) ? fs : 13);
      }
      function px(n) { return n + 'px'; }
      function getPx(el, prop) {
        const v = parseFloat(getComputedStyle(el)[prop] || '0');
        return Number.isFinite(v) ? v : 0;
      }

      function measure(tile) {
        const padV = getPx(tile, 'paddingTop') + getPx(tile, 'paddingBottom');
        const innerH = tile.clientHeight - padV;

        const header = tile.querySelector('.tile-header');
        const status = tile.querySelector('.tile-status');
        const sub    = tile.querySelector('.tile-sub');

        if (!header || !status || !sub) return { innerH: 0 };

        const headerH = header.offsetHeight;
        const statusH = status.offsetHeight + getPx(status, 'marginTop');
        const subH    = sub.offsetHeight    + getPx(sub,    'marginTop');

        return { innerH, header, status, sub, headerH, statusH, subH };
      }

      function shrinkFont(el, floorPx) {
        const cs = getComputedStyle(el);
        const cur = parseFloat(cs.fontSize || '0');
        if (!Number.isFinite(cur)) return false;
        if (cur <= floorPx) {
          const lh = parseFloat(cs.lineHeight) || 1.2;
          if (lh > MIN_LH) {
            el.style.lineHeight = String(Math.max(MIN_LH, lh - 0.03));
            return true;
          }
          return false;
        }
        el.style.fontSize = px(Math.max(floorPx, cur - STEP_PX));
        return true;
      }

      function resetToBase(tile, m) {
        const hDay  = tile.querySelector('.tile-day');
        const hDate = tile.querySelector('.tile-date');

        if (tile.__fitInit) {
          if (tile.__fitInit.statusFS) m.status.style.fontSize = tile.__fitInit.statusFS;
          if (tile.__fitInit.subFS)    m.sub.style.fontSize    = tile.__fitInit.subFS;
          if (tile.__fitInit.subLH)    m.sub.style.lineHeight  = tile.__fitInit.subLH;

          if (hDay && tile.__fitInit.dayFS)  hDay.style.fontSize = tile.__fitInit.dayFS;
          if (hDate&& tile.__fitInit.dateFS) hDate.style.fontSize= tile.__fitInit.dateFS;
          if (hDay && tile.__fitInit.dayLH)  hDay.style.lineHeight = tile.__fitInit.dayLH;
          if (hDate&& tile.__fitInit.dateLH) hDate.style.lineHeight= tile.__fitInit.dateLH;
        } else {
          // First-run cache
          tile.__fitInit = {
            statusFS: getComputedStyle(m.status).fontSize,
            subFS:    getComputedStyle(m.sub).fontSize,
            subLH:    getComputedStyle(m.sub).lineHeight,
            dayFS:    hDay ? getComputedStyle(hDay).fontSize : '',
            dateFS:   hDate ? getComputedStyle(hDate).fontSize : '',
            dayLH:    hDay ? getComputedStyle(hDay).lineHeight : '',
            dateLH:   hDate ? getComputedStyle(hDate).lineHeight : ''
          };
        }
      }

      // Shrink order: Row 2 (status) -> Row 1 (day/date). Row 3 protected.
      function fitTile(tile) {
        let m = measure(tile);
        if (!m.innerH) return;

        resetToBase(tile, m);
        m = measure(tile);

        const subMinPx = Math.max(MIN_SUB_PX, emToPx(m.sub, SUB_MIN_LINES));
        let remaining = (m.headerH + m.statusH + Math.max(m.subH, subMinPx)) - m.innerH;

        if (remaining <= EPSILON) return;

        let guards = 0;
        while (remaining > EPSILON && guards++ < 80) {
          if (shrinkFont(m.status, MIN_STATUS_PX)) {
            m = measure(tile);
            remaining = (m.headerH + m.statusH + Math.max(m.subH, subMinPx)) - m.innerH;
            continue;
          }

          const hDay  = tile.querySelector('.tile-day');
          const hDate = tile.querySelector('.tile-date');
          let did = false;
          if (hDay)  did = shrinkFont(hDay,  MIN_HDR_PX) || did;
          if (hDate) did = shrinkFont(hDate, MIN_HDR_PX) || did;

          m = measure(tile);
          remaining = (m.headerH + m.statusH + Math.max(m.subH, subMinPx)) - m.innerH;

          if (!did) break;
        }
      }

      function fitAllTiles() {
        const grid = document.querySelector(GRID_SEL);
        if (!grid) return;
        grid.querySelectorAll('.tile').forEach(fitTile);
      }

      // Refit on viewport changes
      window.addEventListener('resize', () => requestAnimationFrame(fitAllTiles));
      window.addEventListener('orientationchange', () => setTimeout(() => requestAnimationFrame(fitAllTiles), 250));
      if (window.visualViewport) {
        window.visualViewport.addEventListener('resize', () => requestAnimationFrame(fitAllTiles));
      }

      // Observe grid changes (app.js re-renders tiles)
      const obsInit = () => {
        const grid = document.querySelector(GRID_SEL);
        if (!grid) return;
        const mo = new MutationObserver(() => requestAnimationFrame(fitAllTiles));
        mo.observe(grid, { childList: true, subtree: true });
        requestAnimationFrame(fitAllTiles);

        // iOS can settle late after bars animate — one more pass
        if (isIOS) setTimeout(() => requestAnimationFrame(fitAllTiles), 350);
      };

      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', obsInit);
      } else {
        obsInit();
      }
      window.addEventListener('load', () => requestAnimationFrame(fitAllTiles));
    })();
  </script>
</body>
</html>
