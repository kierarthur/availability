<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <meta name="theme-color" content="#111" />
  <link rel="manifest" href="manifest.json" />
  <title>Availability</title>
  <style>
    :root {
      --bg: #0f1115;
      --panel: #161a22;
      --muted: #a7b0c0;
      --text: #e7ecf3;
      --accent: #4f8cff;
      --danger: #e06666;
      --ok: #6aa84f;
      --warn: #c8a94a;
      --tile: #1b212c;
      --tile-hover: #222a38;
      --booked: #4a86e8;
      --blocked: #6aa84f;

      /* Managed from JS */
      --vh: 1vh;          /* app.js may set this; we override on iOS below */
      --header-h: 56px;   /* overwritten by app.js -> sizeGrid() */
      --footer-h: 76px;   /* visual footer content height (excluding safe area) */
      --rows: 2;          /* app.js sets the real row count (14 tiles / cols) */

      /* Layout helpers */
      --row-gap: .6rem;   /* must match .grid gap */
      --main-vpad: 16px;  /* total vertical padding inside main */

      /* iPhone-specific helpers (defaults harmless elsewhere) */
      --footer-safe: env(safe-area-inset-bottom); /* 0 on non‑notch devices */
      --ios-bottom-guard: 0px;    /* we set to ~12px on iPhone via JS */

      /* Small slack to avoid starving the last row due to sub‑pixel jitter */
      --row-safety: 12px;
    }

    * { box-sizing: border-box; }

    html, body {
      margin: 0;
      padding: 0;
      background: var(--bg);
      color: var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;

      /* Stop iOS auto-text zoom from changing measurements */
      -webkit-text-size-adjust: 100%;

      /* No page‑level scrolling; grid is exact‑fit */
      height: calc(var(--vh) * 100);
      overflow: hidden;

      display: flex;
      flex-direction: column;
    }

    header {
      position: sticky; top: 0; z-index: 10;
      display: flex; align-items: center; gap: .6rem; flex-wrap: wrap;
      padding: .6rem .9rem;
      background: rgba(15,17,21,.9); backdrop-filter: blur(6px);
      border-bottom: 1px solid #222936;

      /* allow the overlay logo to extend without pushing layout */
      overflow: visible;
    }

    /* Candidate name + overlay container */
    .name-and-logo {
      position: relative;          /* positioning context for the overlay */
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      gap: 0.2rem;
      z-index: 2;                  /* above the watermark */
    }

    #candidateName {
      margin: 0;
      font-size: 1.35rem;
      line-height: 1.1;
      font-weight: 800;
      letter-spacing: .2px;
      position: relative;
      z-index: 2;                  /* ensure text stays above the logo */
    }

    /* ===== Overlayed logo (does not take layout space) ===== */
    .company-logo-overlay {
      position: absolute;
      left: 0;
      top: calc(100% + 4px);       /* visually under the name */
      z-index: 1;
      pointer-events: none;        /* do not block clicks/taps */
      opacity: 0.25;               /* watermark feel */

      width: auto;
      height: auto;
      max-width: min(65vw, 520px);
      max-height: 280px;
    }
    @media (max-width: 900px) {
      .company-logo-overlay {
        max-width: min(70vw, 420px);
        max-height: 220px;
        opacity: 0.22;
      }
    }
    @media (max-width: 560px) {
      .company-logo-overlay {
        max-width: 60vw;
        max-height: 180px;
        opacity: 0.20;
      }
    }

    header .spacer { flex: 1; }

    button, .btn {
      appearance: none; border: 0; outline: 0; cursor: pointer;
      border-radius: 10px; padding: .5rem .7rem; font-weight: 600; font-size: .9rem;
      background: var(--panel); color: var(--text);
      transition: background .15s ease, opacity .15s ease;
      position: relative;
      z-index: 2;                  /* above the watermark */
    }
    button:hover { background: #1e2532; }
    button:disabled { opacity: .55; cursor: not-allowed; }
    .btn-primary { background: var(--accent); color: #fff; }
    .btn-ghost { background: transparent; color: var(--muted); }

    main {
      /* Take all space between header and footer */
      flex: 1;
      min-height: 0;              /* allow the grid to shrink within */
      display: flex;
      flex-direction: column;

      /* Keep vertical padding very small so math stays exact */
      padding: .6rem .9rem 0;
      max-width: 1024px;
      width: 100%;
      margin: 0 auto;
      box-sizing: border-box;
    }

    #helpMsg {
      display: block;
      margin: .15rem 0 .6rem;
      padding: .45rem .6rem;
      border-radius: 10px; font-size: .9rem;
      color: var(--muted);
      border: 1px solid #2a3446;
      background: #131926;

      /* Let the grid take the remaining space below */
      flex: 0 0 auto;
      position: relative;
      z-index: 1; /* sits below header components by default */
    }

    /* The calendar grid fills the remaining space in main exactly */
    .grid {
      flex: 1 1 auto;
      min-height: 0;                  /* critical for nested flex */
      display: grid;
      grid-template-columns: repeat(7, minmax(0, 1fr));
      gap: var(--row-gap);
      width: 100%;
      max-width: 100%;

      /* Available height = true viewport - header - footer - main padding
         Subtract total vertical gaps: (rows - 1) * row-gap
         Subtract iPhone footer safe-area + iOS guard so last row never hides
         Add a small safety margin for sub-pixel jitter
         Then divide evenly across rows. */
      grid-auto-rows: calc(
        (
          (var(--vh) * 100)
          - var(--header-h)
          - var(--footer-h)
          - var(--footer-safe)      /* iPhone home-indicator space */
          - var(--ios-bottom-guard) /* iPhone-only gap above footer */
          - var(--main-vpad)
          - ((var(--rows) - 1) * var(--row-gap))
          + var(--row-safety)
        ) / var(--rows)
      );
    }
    @media (max-width: 900px) { .grid { grid-template-columns: repeat(5, 1fr); } }
    @media (max-width: 700px) { .grid { grid-template-columns: repeat(4, 1fr); } }
    @media (max-width: 560px) { .grid { grid-template-columns: repeat(3, 1fr); } }

    /* --- Tile layout: make status align across all tiles --- */
    .tile {
      background: var(--tile);
      border: 1px solid #222a36;
      border-radius: 14px;
      padding: .6rem;

      /* Header (auto), Status (auto), Details must always retain some space */
      display: grid;
      grid-template-rows: auto auto minmax(1.2em, 1fr); /* header, status, sub */

      transition: background .15s ease;
      overflow: hidden;   /* ensure no scroll inside tiles */
    }
    .tile:hover { background: var(--tile-hover); }

    .tile-header {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      gap: .1rem;
      min-height: 30px; /* stabiliser so tiny wrapping doesn't nudge status */
    }
    .tile-day {
      font-weight: 800;
      letter-spacing: .5px;
      font-size: .92rem;
      color: var(--muted);
      text-transform: uppercase;
    }
    .tile-date {
      font-size: .92rem;
      color: var(--text);
      font-weight: 700;
      margin-left: 0.05rem;
    }

    .tile-status {
      margin-top: .25rem;
      font-size: .92rem;
      font-weight: 800;
      /* allow two lines if needed */
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
      overflow: hidden;
    }
    .status-pending { color: var(--muted); }
    .status-na      { color: var(--danger); }
    .status-ld,
    .status-n,
    .status-ldn     { color: var(--warn); }
    .status-booked  { color: var(--booked); }
    .status-blocked { color: var(--blocked); }

    /* Sub info occupies the final row; its height won't push the status */
    .tile-sub {
      margin-top: .2rem;
      color: var(--muted);
      font-size: .8rem;
      line-height: 1.2;
      overflow: hidden;          /* stay within tile */
      min-height: 1.4em;         /* protect from collapsing to 0 */
    }
    .tile .edit-note { color: var(--accent); font-size: .78rem; }

    /* Footer: kept in flow to reserve height; only visibility toggles */
    .footer {
      position: sticky;
      bottom: 0;
      z-index: 20;
      background: rgba(15,17,21,.95); backdrop-filter: blur(6px);
      border-top: 1px solid #222936;
      height: var(--footer-h);
      padding: .7rem .9rem calc(.7rem + env(safe-area-inset-bottom));
      box-sizing: border-box;
      width: 100%;
      flex: 0 0 auto;  /* fixed height footer in the flex column */
    }
    .footer-inner {
      max-width: 1024px; margin: 0 auto;
      display: flex; gap: .6rem; align-items: center;
      width: 100%;
    }
    .footer .spacer { flex: 1; }

    .banner {
      padding: .55rem .7rem; border-radius: 10px; font-size: .88rem;
      border: 1px solid #2a3446; background: #131926; color: #a7b0c0;
    }

    /* IMPORTANT: keep space but hide visually so layout doesn't jump */
    .hidden {
      visibility: hidden !important;   /* still reserves space */
      pointer-events: none !important;
      opacity: 0;                      /* nicer transition if animated later */
    }

    /* Toast (optional) */
    .toast {
      position: fixed; right: .75rem; bottom: calc(5.25rem + env(safe-area-inset-bottom));
      background: #131926; color: var(--text);
      border: 1px solid #2a3446; padding: .6rem .75rem; border-radius: 10px; z-index: 25;
      box-shadow: 0 8px 30px rgba(0,0,0,.35);
      max-width: 90vw; font-size: .9rem;
    }

    /* Short screens: minor base reductions; fit logic will fine-tune per tile */
    @media (max-height: 740px) {
      .tile-day, .tile-date { font-size: .9rem; }
      .tile-status { font-size: .9rem; }
    }
  </style>
</head>
<body>
  <header>
    <div class="name-and-logo">
      <h1 id="candidateName"></h1>
      <!-- Overlayed logo (does not affect layout) -->
      <img src="ARMSLOGO.png" alt="Company Logo" class="company-logo-overlay" />
    </div>
    <div class="spacer"></div>
    <button id="refreshBtn">Refresh</button>
    <button id="installBtn" class="btn-ghost hidden">Install</button>
  </header>

  <main>
    <div id="helpMsg">
      Please tap any date to change your availability — don’t forget to tap <strong>Submit</strong> when you’re done.
    </div>
    <div id="grid" class="grid"></div>
  </main>

  <!-- Footer space is always reserved; only visibility toggles via .hidden -->
  <div id="footer" class="footer hidden" role="region" aria-label="Submission actions">
    <div class="footer-inner">
      <span id="draftMsg" class="banner">You have unsaved changes.</span>
      <div class="spacer"></div>
      <button id="clearBtn" class="btn">Clear changes</button>
      <button id="submitBtn" class="btn-primary">Submit</button>
    </div>
  </div>

  <div id="toast" class="toast hidden" role="status" aria-live="polite"></div>

  <!-- Your app logic -->
  <script src="app.js"></script>

  <!-- iPhone dynamic viewport + Budgeted shrink engine -->
  <script>
    (function () {
      const GRID_SEL = '#grid';

      // -------- iPhone-specific viewport handling --------
      const isIOS = (() => {
        if (typeof navigator === 'undefined') return false;
        const ua = navigator.userAgent || '';
        return /iPhone|iPad|iPod/i.test(ua) && !('MSStream' in window);
      })();

      function setVH() {
        // Prefer the visual viewport height on iOS, else innerHeight
        const h = (isIOS && window.visualViewport)
          ? window.visualViewport.height
          : window.innerHeight;
        // Publish as 1% unit
        document.documentElement.style.setProperty('--vh', (h * 0.01) + 'px');
        // On iOS also ensure a tiny visible gap above footer
        if (isIOS) {
          document.documentElement.style.setProperty('--ios-bottom-guard', '12px');
        }
      }

      // Initial and delayed recompute (iOS can settle late after UI bars animate)
      setVH();
      window.addEventListener('load', () => { setVH(); setTimeout(setVH, 350); });
      window.addEventListener('resize', setVH);
      window.addEventListener('orientationchange', () => setTimeout(setVH, 250));
      if (window.visualViewport) {
        window.visualViewport.addEventListener('resize', setVH);
      }

      // -------- Budgeted shrink engine (protect Row 3) --------
      const MIN_SUB_PX    = 10;   // details row can go small, but visible
      const MIN_STATUS_PX = 11;
      const MIN_HDR_PX    = 12;   // header day/date together
      const MIN_LH        = 1.06; // tight but readable
      const STEP_PX       = 1;    // shrink step
      const EPSILON       = 1.5;  // px hysteresis to avoid jitter

      const SUB_MIN_LINES = 1.2;  // ~1 line minimum

      function emToPx(el, em) {
        const fs = parseFloat(getComputedStyle(el).fontSize || '13');
        return em * (Number.isFinite(fs) ? fs : 13);
      }

      function px(n) { return n + 'px'; }

      function getPx(el, prop) {
        const v = parseFloat(getComputedStyle(el)[prop] || '0');
        return Number.isFinite(v) ? v : 0;
      }

      function measure(tile) {
        const padV = getPx(tile, 'paddingTop') + getPx(tile, 'paddingBottom');
        const innerH = tile.clientHeight - padV;

        const header = tile.querySelector('.tile-header');
        const status = tile.querySelector('.tile-status');
        const sub    = tile.querySelector('.tile-sub');

        if (!header || !status || !sub) return { innerH: 0 };

        const headerH = header.offsetHeight;
        const statusH = status.offsetHeight + getPx(status, 'marginTop');
        const subH    = sub.offsetHeight    + getPx(sub,    'marginTop');

        return { innerH, header, status, sub, headerH, statusH, subH };
      }

      function shrinkFont(el, floorPx) {
        const cs = getComputedStyle(el);
        const cur = parseFloat(cs.fontSize || '0');
        if (!Number.isFinite(cur)) return false;
        if (cur <= floorPx) {
          // Try a little line-height tighten if possible
          const lh = parseFloat(cs.lineHeight) || 1.2;
          if (lh > MIN_LH) {
            el.style.lineHeight = String(Math.max(MIN_LH, lh - 0.03));
            return true;
          }
          return false;
        }
        el.style.fontSize = px(Math.max(floorPx, cur - STEP_PX));
        return true;
      }

      function resetToBase(tile, m) {
        const hDay  = tile.querySelector('.tile-day');
        const hDate = tile.querySelector('.tile-date');

        if (tile.__fitInit) {
          if (tile.__fitInit.statusFS) m.status.style.fontSize = tile.__fitInit.statusFS;
          if (tile.__fitInit.subFS)    m.sub.style.fontSize    = tile.__fitInit.subFS;
          if (tile.__fitInit.subLH)    m.sub.style.lineHeight  = tile.__fitInit.subLH;

          if (hDay && tile.__fitInit.dayFS)  hDay.style.fontSize = tile.__fitInit.dayFS;
          if (hDate&& tile.__fitInit.dateFS) hDate.style.fontSize= tile.__fitInit.dateFS;
          if (hDay && tile.__fitInit.dayLH)  hDay.style.lineHeight = tile.__fitInit.dayLH;
          if (hDate&& tile.__fitInit.dateLH) hDate.style.lineHeight= tile.__fitInit.dateLH;
        } else {
          // First-run cache
          tile.__fitInit = {
            statusFS: getComputedStyle(m.status).fontSize,
            subFS:    getComputedStyle(m.sub).fontSize,
            subLH:    getComputedStyle(m.sub).lineHeight,
            dayFS:    hDay ? getComputedStyle(hDay).fontSize : '',
            dateFS:   hDate ? getComputedStyle(hDate).fontSize : '',
            dayLH:    hDay ? getComputedStyle(hDay).lineHeight : '',
            dateLH:   hDate ? getComputedStyle(hDate).lineHeight : ''
          };
        }
      }

      // Budgeted shrink: protect Row 3 by reclaiming from status then header
      function fitTile(tile) {
        let m = measure(tile);
        if (!m.innerH) return;

        // Always start from base sizes to avoid cumulative shrink
        resetToBase(tile, m);
        m = measure(tile);

        const subMinPx = Math.max(MIN_SUB_PX, emToPx(m.sub, SUB_MIN_LINES));
        const need = (m.headerH + m.statusH + Math.max(m.subH, subMinPx)) - m.innerH;

        if (need <= EPSILON) return; // plenty of space; do nothing

        // Reclaim budget only as much as needed
        let remaining = need;
        let guards = 0;

        while (remaining > EPSILON && guards++ < 80) {
          // 1) Squeeze Row 2 (status) first
          if (shrinkFont(m.status, MIN_STATUS_PX)) {
            m = measure(tile);
            remaining = (m.headerH + m.statusH + Math.max(m.subH, subMinPx)) - m.innerH;
            continue;
          }

          // 2) Then Row 1 (header: day & date together)
          const hDay  = tile.querySelector('.tile-day');
          const hDate = tile.querySelector('.tile-date');
          let did = false;
          if (hDay)  did = shrinkFont(hDay,  MIN_HDR_PX) || did;
          if (hDate) did = shrinkFont(hDate, MIN_HDR_PX) || did;

          m = measure(tile);
          remaining = (m.headerH + m.statusH + Math.max(m.subH, subMinPx)) - m.innerH;

          if (!did) break; // hit floors everywhere; stop
        }
      }

      function fitAllTiles() {
        const grid = document.querySelector(GRID_SEL);
        if (!grid) return;
        grid.querySelectorAll('.tile').forEach(fitTile);
      }

      // Refit on resize/orientation
      window.addEventListener('resize', () => { requestAnimationFrame(fitAllTiles); });
      window.addEventListener('orientationchange', () => {
        setTimeout(() => requestAnimationFrame(fitAllTiles), 250);
      });

      // Observe grid changes (app.js re-renders tiles)
      const obsInit = () => {
        const grid = document.querySelector(GRID_SEL);
        if (!grid) return;
        const mo = new MutationObserver(() => {
          // Batch with rAF to avoid thrash during mass updates
          requestAnimationFrame(fitAllTiles);
        });
        mo.observe(grid, { childList: true, subtree: true });
        // Initial fit (in case tiles are already there)
        requestAnimationFrame(fitAllTiles);

        // iOS can settle late after bars animate — do one more pass shortly after
        if (isIOS) {
          setTimeout(() => requestAnimationFrame(fitAllTiles), 350);
        }
      };

      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', obsInit);
      } else {
        obsInit();
      }
      // Also, run once after the page fully settles (images/fonts)
      window.addEventListener('load', () => requestAnimationFrame(fitAllTiles));
    })();
  </script>
</body>
</html>
