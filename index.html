<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <meta name="theme-color" content="#111" />
  <link rel="manifest" href="manifest.json" />
  <title>Availability</title>
  <style>
    :root {
      --bg: #0f1115;
      --panel: #161a22;
      --muted: #a7b0c0;
      --text: #e7ecf3;
      --accent: #4f8cff;
      --danger: #e06666;
      --ok: #6aa84f;
      --warn: #c8a94a;
      --tile: #1b212c;
      --tile-hover: #222a38;
      --booked: #4a86e8;
      --blocked: #6aa84f;

      /* Managed from JS */
      --vh: 1vh;          /* app.js sets this to 1% of window.innerHeight */
      --header-h: 56px;   /* overwritten by app.js -> sizeGrid() */
      --footer-h: 76px;   /* overwritten by app.js -> sizeGrid() */
      --rows: 2;          /* app.js sets the real row count (14 tiles / cols) */

      /* Layout helpers */
      --row-gap: .6rem;   /* must match .grid gap */
      --main-vpad: 16px;  /* total vertical padding inside main */

      /* NEW: tiny slack so the last row doesn't collapse on tight viewports */
      --row-safety: 10px;
    }

    * { box-sizing: border-box; }

    html, body {
      margin: 0;
      padding: 0;
      background: var(--bg);
      color: var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;

      /* No scrollbars anywhere */
      height: calc(var(--vh) * 100);
      overflow: hidden;

      /* Flex column for header / content / footer */
      display: flex;
      flex-direction: column;
    }

    header {
      position: sticky; top: 0; z-index: 10;
      display: flex; align-items: center; gap: .6rem; flex-wrap: wrap;
      padding: .6rem .9rem;
      background: rgba(15,17,21,.9); backdrop-filter: blur(6px);
      border-bottom: 1px solid #222936;

      /* allow the overlay logo to extend without pushing layout */
      overflow: visible;
    }

    /* Candidate name + overlay container */
    .name-and-logo {
      position: relative;          /* positioning context for the overlay */
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      gap: 0.2rem;
      z-index: 2;                  /* above the watermark */
    }

    #candidateName {
      margin: 0;
      font-size: 1.35rem;
      line-height: 1.1;
      font-weight: 800;
      letter-spacing: .2px;
      position: relative;
      z-index: 2;                  /* ensure text stays above the logo */
    }

    /* ===== Overlayed logo (does not take layout space) ===== */
    .company-logo-overlay {
      position: absolute;
      left: 0;
      top: calc(100% + 4px);       /* visually under the name */
      z-index: 1;
      pointer-events: none;        /* do not block clicks/taps */
      opacity: 0.25;               /* watermark feel; adjust as needed */

      width: auto;
      height: auto;
      max-width: min(65vw, 520px);
      max-height: 280px;
    }
    @media (max-width: 900px) {
      .company-logo-overlay {
        max-width: min(70vw, 420px);
        max-height: 220px;
        opacity: 0.22;
      }
    }
    @media (max-width: 560px) {
      .company-logo-overlay {
        max-width: 60vw;
        max-height: 180px;
        opacity: 0.20;
      }
    }

    header .spacer { flex: 1; }

    button, .btn {
      appearance: none; border: 0; outline: 0; cursor: pointer;
      border-radius: 10px; padding: .5rem .7rem; font-weight: 600; font-size: .9rem;
      background: var(--panel); color: var(--text);
      transition: background .15s ease, opacity .15s ease;
      position: relative;
      z-index: 2;                  /* above the watermark */
    }
    button:hover { background: #1e2532; }
    button:disabled { opacity: .55; cursor: not-allowed; }
    .btn-primary { background: var(--accent); color: #fff; }
    .btn-ghost { background: transparent; color: var(--muted); }

    main {
      /* Take all space between header and footer */
      flex: 1;
      min-height: 0;              /* allow the grid to shrink within */
      display: flex;
      flex-direction: column;

      /* Keep vertical padding very small so math stays exact */
      padding: .6rem .9rem 0;
      max-width: 1024px;
      width: 100%;
      margin: 0 auto;
      box-sizing: border-box;
    }

    #helpMsg {
      display: block;
      margin: .15rem 0 .6rem;
      padding: .45rem .6rem;
      border-radius: 10px; font-size: .9rem;
      color: var(--muted);
      border: 1px solid #2a3446;
      background: #131926;

      /* Let the grid take the remaining space below */
      flex: 0 0 auto;
      position: relative;
      z-index: 1; /* sits below header components by default */
    }

    /* The calendar grid fills the remaining space in main exactly */
    .grid {
      flex: 1 1 auto;
      min-height: 0;                  /* critical for nested flex */
      display: grid;
      grid-template-columns: repeat(7, minmax(0, 1fr));
      gap: var(--row-gap);
      width: 100%;
      max-width: 100%;

      /* Available height = true viewport - header - footer - main padding
         Subtract total vertical gaps: (rows - 1) * row-gap
         Add a small safety margin so the last row doesn't collapse on tight viewports */
      grid-auto-rows: calc(
        (
          (var(--vh) * 100) - var(--header-h) - var(--footer-h) - var(--main-vpad)
          - ((var(--rows) - 1) * var(--row-gap))
          + var(--row-safety)
        ) / var(--rows)
      );
    }
    @media (max-width: 900px) { .grid { grid-template-columns: repeat(5, 1fr); } }
    @media (max-width: 700px) { .grid { grid-template-columns: repeat(4, 1fr); } }
    @media (max-width: 560px) { .grid { grid-template-columns: repeat(3, 1fr); } }

    /* --- Tile layout: make status align across all tiles --- */
    .tile {
      background: var(--tile);
      border: 1px solid #222a36;
      border-radius: 14px;
      padding: .6rem;

      /* 3-row grid so status sits in a consistent row.
         Force the details row to have a minimum height so it can't collapse. */
      display: grid;
      grid-template-rows: auto auto minmax(1.8em, 1fr); /* header, status, sub */

      transition: background .15s ease;
      overflow: hidden;   /* avoid inner scroll */
    }
    .tile:hover { background: var(--tile-hover); }

    .tile-header {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      gap: .1rem;
      min-height: 34px; /* stabilizer so tiny wrapping doesn't nudge status */
    }
    .tile-day {
      font-weight: 800;
      letter-spacing: .5px;
      font-size: .92rem;
      color: var(--muted);
      text-transform: uppercase;
    }
    .tile-date {
      font-size: .92rem;
      color: var(--text);
      font-weight: 700;
      margin-left: 0.05rem;
    }

    .tile-status {
      margin-top: .3rem;
      font-size: .92rem;
      font-weight: 800;
      /* allow two lines if needed */
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
      overflow: hidden;
    }
    .status-pending { color: var(--muted); }
    .status-na      { color: var(--danger); }
    .status-ld,
    .status-n,
    .status-ldn     { color: var(--warn); }
    .status-booked  { color: var(--booked); }
    .status-blocked { color: var(--blocked); }

    /* Sub info (details). Give it a minimum so at least one line always shows. */
    .tile-sub {
      margin-top: .2rem;
      color: var(--muted);
      font-size: .8rem;
      line-height: 1.2;
      overflow: hidden;          /* stay within tile */
      min-height: 1.6em;         /* NEW: protect from collapsing to 0 */
    }
    .tile .edit-note { color: var(--accent); font-size: .78rem; }

    /* Footer: kept in flow to reserve height; only visibility toggles */
    .footer {
      position: sticky;
      bottom: 0;
      z-index: 20;
      background: rgba(15,17,21,.95); backdrop-filter: blur(6px);
      border-top: 1px solid #222936;
      height: var(--footer-h);
      padding: .7rem .9rem calc(.7rem + env(safe-area-inset-bottom));
      box-sizing: border-box;
      width: 100%;
      flex: 0 0 auto;  /* fixed height footer in the flex column */
    }
    .footer-inner {
      max-width: 1024px; margin: 0 auto;
      display: flex; gap: .6rem; align-items: center;
      width: 100%;
    }
    .footer .spacer { flex: 1; }

    .banner {
      padding: .55rem .7rem; border-radius: 10px; font-size: .88rem;
      border: 1px solid #2a3446; background: #131926; color: #a7b0c0;
    }

    /* IMPORTANT: keep space but hide visually so layout doesn't jump */
    .hidden {
      visibility: hidden !important;
      pointer-events: none !important;
    }

    /* Toast (optional) */
    .toast {
      position: fixed; right: .75rem; bottom: calc(5.25rem + env(safe-area-inset-bottom));
      background: #131926; color: var(--text);
      border: 1px solid #2a3446; padding: .6rem .75rem; border-radius: 10px; z-index: 25;
      box-shadow: 0 8px 30px rgba(0,0,0,.35);
      max-width: 90vw; font-size: .9rem;
    }

    /* Short screens: scale text a touch to avoid clipping */
    @media (max-height: 740px) {
      .tile-day, .tile-date { font-size: .9rem; }
      .tile-status { font-size: .9rem; }
    }
  </style>
</head>
<body>
  <header>
    <div class="name-and-logo">
      <h1 id="candidateName"></h1>
      <!-- Overlayed logo (does not affect layout) -->
      <img src="ARMSLOGO.png" alt="Company Logo" class="company-logo-overlay" />
    </div>
    <div class="spacer"></div>
    <button id="refreshBtn">Refresh</button>
    <button id="installBtn" class="btn-ghost hidden">Install</button>
  </header>

  <main>
    <div id="helpMsg">
      Please tap any date to change your availability — don’t forget to tap <strong>Submit</strong> when you’re done.
    </div>
    <div id="grid" class="grid"></div>
  </main>

  <!-- Footer space is always reserved; only visibility toggles via .hidden -->
  <div id="footer" class="footer hidden" role="region" aria-label="Submission actions">
    <div class="footer-inner">
      <span id="draftMsg" class="banner">You have unsaved changes.</span>
      <div class="spacer"></div>
      <button id="clearBtn" class="btn">Clear changes</button>
      <button id="submitBtn" class="btn-primary">Submit</button>
    </div>
  </div>

  <div id="toast" class="toast hidden" role="status" aria-live="polite"></div>

  <!-- Your app logic -->
  <script src="app.js"></script>

  <!-- Auto-fit text so each tile always fits without clipping -->
  <script>
    (function () {
      const GRID_SEL = '#grid';

      // Minimum pixel sizes to preserve legibility
      const MIN_SUB_PX    = 11;   // tile-sub
      const MIN_STATUS_PX = 12;   // tile-status
      const MIN_HDR_PX    = 13;   // header lines (day/date)

      // Optional gentle line-height tightening when needed
      const MIN_LH = 1.10;
      const STEP_PX = 1;          // shrink step

      function px(n) { return n + 'px'; }

      function getNumericPx(el, prop) {
        const v = parseFloat(getComputedStyle(el)[prop] || '0');
        return Number.isFinite(v) ? v : 0;
      }

      function measureTile(tile) {
        const padV = getNumericPx(tile, 'paddingTop') + getNumericPx(tile, 'paddingBottom');
        const innerH = tile.clientHeight - padV;

        const header = tile.querySelector('.tile-header');
        const status = tile.querySelector('.tile-status');
        const sub    = tile.querySelector('.tile-sub');

        if (!header || !status || !sub) return { innerH: 0, contentH: 0 };

        const headerH = header.offsetHeight;
        const statusH = status.offsetHeight + getNumericPx(status, 'marginTop'); // include margin
        const subH    = sub.offsetHeight + getNumericPx(sub, 'marginTop');

        const contentH = headerH + statusH + subH;
        return { innerH, contentH, header, status, sub };
      }

      function shrinkElement(el, floorPx) {
        const cs = getComputedStyle(el);
        const curPx = parseFloat(cs.fontSize || '0');
        if (!Number.isFinite(curPx)) return false;
        if (curPx <= floorPx) {
          // Try tiny line-height tighten if allowed
          const curLh = parseFloat(cs.lineHeight) || 1.2;
          if (curLh > MIN_LH) {
            el.style.lineHeight = String(Math.max(MIN_LH, curLh - 0.03));
            return true;
          }
          return false; // cannot shrink further
        }
        el.style.fontSize = px(Math.max(floorPx, curPx - STEP_PX));
        return true;
      }

      // Shrink in order: sub -> status -> header (date then day together)
      function fitTile(tile) {
        const m = measureTile(tile);
        if (!m.innerH) return;

        // Cache original sizes on first run so repeated passes don't keep shrinking
        if (!tile.__fitInit) {
          const hDay  = tile.querySelector('.tile-day');
          const hDate = tile.querySelector('.tile-date');
          tile.__fitInit = {
            statusFS: getComputedStyle(m.status).fontSize,
            subFS:    getComputedStyle(m.sub).fontSize,
            subLH:    getComputedStyle(m.sub).lineHeight,
            dayFS:    hDay ? getComputedStyle(hDay).fontSize : '',
            dateFS:   hDate ? getComputedStyle(hDate).fontSize : '',
            dayLH:    hDay ? getComputedStyle(hDay).lineHeight : '',
            dateLH:   hDate ? getComputedStyle(hDate).lineHeight : ''
          };
        } else {
          // Reset to original before fitting again (e.g., on orientation change)
          if (tile.__fitInit.statusFS) m.status.style.fontSize = tile.__fitInit.statusFS;
          if (tile.__fitInit.subFS)    m.sub.style.fontSize    = tile.__fitInit.subFS;
          if (tile.__fitInit.subLH)    m.sub.style.lineHeight  = tile.__fitInit.subLH;
          const hDay = tile.querySelector('.tile-day');
          const hDate= tile.querySelector('.tile-date');
          if (hDay && tile.__fitInit.dayFS)  hDay.style.fontSize = tile.__fitInit.dayFS;
          if (hDate&& tile.__fitInit.dateFS) hDate.style.fontSize= tile.__fitInit.dateFS;
          if (hDay && tile.__fitInit.dayLH)  hDay.style.lineHeight = tile.__fitInit.dayLH;
          if (hDate&& tile.__fitInit.dateLH) hDate.style.lineHeight= tile.__fitInit.dateLH;
        }

        // Iteratively shrink until it fits or we hit floors
        let guards = 0;
        while (guards++ < 40) {
          const { innerH, contentH } = measureTile(tile);
          if (contentH <= innerH) break;

          // 1) sub
          if (shrinkElement(m.sub, MIN_SUB_PX)) continue;

          // 2) status
          if (shrinkElement(m.status, MIN_STATUS_PX)) continue;

          // 3) header (shrink day & date together)
          const day  = tile.querySelector('.tile-day');
          const date = tile.querySelector('.tile-date');
          let headerShrunk = false;
          if (day)  headerShrunk = shrinkElement(day,  MIN_HDR_PX) || headerShrunk;
          if (date) headerShrunk = shrinkElement(date, MIN_HDR_PX) || headerShrunk;
          if (headerShrunk) continue;

          // Nothing else can shrink; stop
          break;
        }
      }

      function fitAllTiles() {
        const grid = document.querySelector(GRID_SEL);
        if (!grid) return;
        const tiles = grid.querySelectorAll('.tile');
        tiles.forEach(fitTile);
      }

      // Refit on resize/orientation
      window.addEventListener('resize', () => { requestAnimationFrame(fitAllTiles); });
      window.addEventListener('orientationchange', () => {
        setTimeout(() => requestAnimationFrame(fitAllTiles), 250);
      });

      // Observe grid changes (app.js re-renders tiles)
      const obsInit = () => {
        const grid = document.querySelector(GRID_SEL);
        if (!grid) return;
        const mo = new MutationObserver(() => {
          // Batch with rAF to avoid thrash during mass updates
          requestAnimationFrame(fitAllTiles);
        });
        mo.observe(grid, { childList: true, subtree: true });
        // Initial fit (in case tiles are already there)
        requestAnimationFrame(fitAllTiles);
      };

      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', obsInit);
      } else {
        obsInit();
      }
      // Also, run once after the page fully settles (images/fonts)
      window.addEventListener('load', () => requestAnimationFrame(fitAllTiles));
    })();
  </script>
</body>
</html>
